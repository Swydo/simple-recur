// Generated by CoffeeScript 1.12.7
(function() {
  var DateString, Recur, dayjs;

  dayjs = this.dayjs || require('dayjs');

  DateString = function(date) {
    return dayjs(date).format('YYYY-MM-DD');
  };

  Recur = (function() {
    Recur.attributes = {
      units: Number,
      measure: String,
      start: DateString,
      end: DateString,
      from: DateString
    };

    function Recur(data) {
      if (data == null) {
        data = {};
      }
      this.set(data);
      this.setDefaults();
    }

    Recur.prototype.set = function(data) {
      var attr;
      if (data == null) {
        data = {};
      }
      for (attr in this.constructor.attributes) {
        if (data[attr] != null) {
          this[attr] = data[attr];
        }
      }
      return this;
    };

    Recur.prototype.setDefaults = function() {
      if (this.units == null) {
        this.units = 1;
      }
      if (this.measure == null) {
        this.measure = 'month';
      }
      return this.start != null ? this.start : this.start = dayjs();
    };

    Recur.prototype.next = function(begin, end) {
      var i, j, ref, ref1, results;
      if (begin == null) {
        begin = 1;
      }
      if (!end) {
        end = begin;
        begin = 0;
      }
      results = [];
      for (i = j = ref = begin, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
        results.push(this.nextAt(i));
      }
      return results;
    };

    Recur.prototype.nextAt = function(count) {
      var correction, next;
      if (count == null) {
        count = 1;
      }
      correction = this.getFromDateCorrection();
      next = dayjs(this.start).startOf('day').add((count + correction) * this.units, this.measure);
      if (this.isAfterEndDate(next)) {
        return null;
      } else {
        return next;
      }
    };

    Recur.prototype.getFromDateCorrection = function() {
      var from, start;
      if (!this.from) {
        return 0;
      }
      if (dayjs(this.from).isBefore(this.start)) {
        return 0;
      }
      start = dayjs(this.start).startOf('day');
      from = dayjs(this.from).startOf('day');
      return Math.ceil(Math.abs(start.diff(from, this.measure, true)) / this.units);
    };

    Recur.prototype.matches = function(date) {
      var diff, start;
      if (this.isBeforeFromDate(date)) {
        return false;
      }
      if (this.isBeforeStartDate(date)) {
        return false;
      }
      if (this.isAfterEndDate(date)) {
        return false;
      }
      date = dayjs(date).startOf('day');
      start = dayjs(this.start).startOf('day');
      diff = start.diff(date, this.measure, true);
      if (diff % this.units === 0) {
        return true;
      }
      return Math.floor(diff) % this.units === 0 && this.isRecurringOnLastDayOfMonth(date);
    };

    Recur.prototype.isBeforeFromDate = function(date) {
      return this.from && dayjs(this.from).startOf('day').isAfter(date);
    };

    Recur.prototype.isBeforeStartDate = function(date) {
      return dayjs(this.start).startOf('day').isAfter(date);
    };

    Recur.prototype.isAfterEndDate = function(date) {
      var endOfEndDay;
      if (!this.end) {
        return false;
      }
      endOfEndDay = dayjs(this.end).endOf('day');
      return dayjs(date).isAfter(endOfEndDay);
    };

    Recur.prototype.isRecurringOnLastDayOfMonth = function(date) {
      var dateMonthEndDay, recurringMonthDay;
      if (this.measure !== 'month') {
        return false;
      }
      recurringMonthDay = dayjs(this.start).date();
      dateMonthEndDay = dayjs(date).endOf('month').date();
      return (recurringMonthDay > dateMonthEndDay) && dayjs(date).date() === dateMonthEndDay;
    };

    Recur.prototype.every = function(units, measure) {
      this.units = units;
      this.measure = measure;
      return this;
    };

    Recur.prototype.clone = function(data) {
      return new this.constructor(this).set(data);
    };

    Recur.prototype.toJSON = function() {
      var attr, json, ref, type;
      json = {};
      ref = this.constructor.attributes;
      for (attr in ref) {
        type = ref[attr];
        if (this[attr] != null) {
          json[attr] = type(this[attr]);
        }
      }
      delete json.from;
      return json;
    };

    return Recur;

  })();

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Recur;
  } else {
    this.Recur = Recur;
  }

}).call(this);
